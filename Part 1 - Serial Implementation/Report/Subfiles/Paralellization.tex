\section{Choice of problem and Options for Parallelization}
While this problem is not fully parallelizable, different parts of the pipeline are parallelizable. This problem was chosen for this reason, because it will be interesting to investigate if parallelization will make this problem faster. Each part of the pipeline will now be taken into consideration, discussing its time and space complexity and its amenability to parallelization:

\begin{enumerate}
	\item Populating the sine and cosine maps: An O(1) operation, performing a total of 360 sin operations and 360 cos operations. Populating each map is parallelizable, where each thread performs a single sine or cosine operation
	\item Generating the points and angles for each line: An O($2^n$) operation, where n is the number of iterations. Here both the x and y coordinates need to be generated, however each iteration depends on the last one to finish first. An optimisation can be done to compute the first \textless block dimension\textgreater\ points in one kernel call with a $syncthreads()$ call within a for loop. For the other iterations, however, the device will need to finish all operations, then be synchronised by the host before starting the next iteration, as each iteration depends on the result of the previous. Note: After generating the points, the memory for the angles may be freed.
	\item Mapping the coordinate space points to image space is fully parallelizable, as this consists of one multiplication and one addition per axis per point. This operation is also O($2^n$) since the number of points has this complexity.
	\item The last part of the pipeline is the image synthesis. Here, each thread may compute a line. It will not matter if both threads write the the same pixel at a time, because the operation is changing a pixel from white to black, hence if one overwrites the other in a random order, the result is still the same. The complexity of this operation is not so straight forward as it depends on the image size, hence this will be determined graphically in section \ref{results}.
\end{enumerate}

Another part which may be parallellized in the case of this implementation is the initialisation of the image matrix, to make it all white at the start. This can be done asynchronously to the first three steps.

An important thing to note is that before a step in the pipeline starts, the last step of the pipeline must finish.

With regards to memory, the only item which will be needed to be copied to the host memory is the image matrix, while everything else may be initialised and remain in memory until it is freed. In terms of memory complexity, this is O($2^n$), as it mostly depends on the number of points to be determined. In exact bytes, we have $2^n * (sizeof(short) * sizeof(float) * 2)$ where the shorts are the list of angles for each point and the floats are the coordinates, one for x and one for y. Then there is also the addition of the sine and cosine maps as well as the image matrix, however these are negligible compared to the size of the other items which depend on the number of iterations. For the points, a limit of 26 iterations is set, because at 26 iterations, $2^n$ will need 640 MB of memory, as the size of a short is typically 2 bytes while the size of a float is typically 4 bytes, meaning the bytes are $10*2^n$.
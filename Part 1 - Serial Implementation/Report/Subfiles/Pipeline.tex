\section{Implementation and Pipeline}
The implementation of this problem is split into several parts. First, we discuss the required user inputs:
\begin{enumerate}
	\item Image width $W$ - The width of the pgm image which will be the final artefact obtained by the program
	\item Image height $H$ - The height of the output image
	\item Length multiplier $m$ - The value by which the length of the parent will be multiplied to get the length of the children (discussed in section \ref{intro})
	\item Rotation per iteration $theta$ - The angle with which the child lines will diverge from that of the parent (discussed in section \ref{intro})
	\item Number of iterations $n$ - How many generations of lines there will be. 1 means that only the first line is drawn.
\end{enumerate}
Next, the several stages of the pipeline to get the desired image is discussed.

First, a cosine and sine list is generated, which maps an angle to its result in sine or cosine. These were generated for angles between -180 to 180 degrees, at an interval of 1, which means the angles in degrees must be an integer. This is a limitation, albeit not a harsh one, but leads to a big optimization so that the sine and cosine function do not need to be called for each line, since these functions are computationally demanding. Instead, to get an angle after generating the map, one can simply do: $sin\_list[\theta + 180]$ to get $sin(\theta)$, and the same with cosine. This also means that the angle $\theta$ must be between -180 and 179 (both included) otherwise the index for the array will go out of bounds.

After this list is generated, we can compute the points for the lines. The first two points for the first line are initialised as $(0, 0)$ and $(0, 1)$. Note how the length of the first line will always be taken as 1. This is because when synthesizing the image, the generated tree will be made to stretch to the image size, hence this initial length will not matter. This design choice was taken because it will not allow any space in the image to be wasted and more importantly so that the tree will not go out of the image bounds. To get the next 2 lines, the principle of matrix multiplication is used. So the points are first placed at $(0, length_{parent} * m)$, then a rotation of $\pm parent_{angle} + \theta$ is applied and finally the position of the parent is added to these points. The 2 new lines are the end of the parent to the 2 new generated points.

The final step before synthesising the image/drawing the lines, is to map the points from coordinate space to image/pixel space. This is needed due to image space starting at $(0, 0)$ at its top-left corner, while coordinate space has $0,0$ at the bottom middle. Therefore, in order to perform this conversion, the following operations are performed: 
\\ \\
$x_{image} = x_{coordinate} * W / (x_{min} - x_{max}) + image_width/2$
\\ \\
$y_{image} = y_{coordinate} * - H / (y_{max} - y_{min}) + H - H*(y_{max}-y_{min}) * y_{min}$
\\ \\\
where $x_{max}$ and $x_{min}$ are the maximum and maximum X values in coordinate space accordingly, and the same for the Y values. Furthermore, as stated before, W is the image width and H is the image height. Note that $x_{min}$ is $-x_{max}$ since the tree is symmetric across x.

The final step of the pipeline is synthesizing the image